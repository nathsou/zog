let print: a => () = raw { console.log }
let raise: str => a = raw { msg => { throw new Error(msg); } }

type Map = { get: str => a, set: (str, a) => (), has: str => bool }
let createMap: () => Map = raw { () => new Map() }
let clone: Map => Map = raw { map => new Map(map) }

type Env = Map

enum BinOp { Add, Sub, Mul, Div, Equ }

enum Expr {
    Num num
    Bool bool
    Var str
    Let { name: str, val: Expr, rhs: Expr }
    LetRec { name: str, arg: str, body: Expr, rhs: Expr }
    Lambda { arg: str, body: Expr }
    Bin { lhs: Expr, op: BinOp, rhs: Expr }
    App { lhs: Expr, arg: Expr }
    If { cond: Expr, ifTrue: Expr, ifFalse: Expr }
}

enum Value {
    Num num
    Bool bool
    Closure { arg: str, body: Expr, env: Env }
    RecClosure { name: str, arg: str, body: Expr, env: Env }
}

let eval = (expr: Expr, env: Env): Value => match expr {
    Expr.Num x => Value.Num x
    Expr.Bool q => Value.Bool q
    Var v => if env.has(v) env.get(v) else raise("undeclared variable")
    Let { name, val, rhs } => {
        let bodyEnv = env->clone
        bodyEnv.set(name, val->eval(env))
        rhs->eval(bodyEnv)
    }
    LetRec { name, arg, body, rhs } => {
        let bodyEnv = env->clone
        bodyEnv.set(name, RecClosure { name: name, arg: arg, body: body, env: env })
        rhs->eval(bodyEnv)
    }
    Bin { lhs, op, rhs } => match (lhs->eval(env), rhs->eval(env)) {
        (Value.Num a, Value.Num b) => match op {
            Add => Value.Num a + b
            Sub => Value.Num a - b
            Mul => Value.Num a * b
            Div => Value.Num a / b
            Equ => Value.Bool a == b
        }
        (Value.Bool a, Value.Bool b) => match op {
            Equ => Value.Bool a == b
        }
        _ => raise("invalid operands in binary expression")
    }
    Lambda { arg, body } => Closure { arg: arg, body: body, env: env->clone }
    App { lhs, arg } => {
        match lhs->eval(env) {
            Closure { arg: argName, body, env: bodyEnv } => {
                bodyEnv.set(argName, arg->eval(env))
                body->eval(bodyEnv)
            }
            RecClosure { name, arg: argName, body, env: bodyEnv } => {
                bodyEnv.set(name, Closure { arg: argName, body: body, env: bodyEnv })
                bodyEnv.set(argName, arg->eval(env))
                body->eval(bodyEnv)
            }
            _ => raise("cannot call non-closure value")
        }
    }
    If { cond, ifTrue, ifFalse } => {
        match cond->eval(env) {
            Value.Bool true => ifTrue->eval(env)
            Value.Bool false => ifFalse->eval(env)
            _ => raise("expected if condition to be a bool")
        }
    }
}

let env = createMap()

let fact = n => LetRec {
    name: "f",
    arg: "n",
    body: Bin {
        lhs: Var "n",
        op: Mul,
        rhs: If {
            cond: Bin { lhs: Var "n", op: Equ, rhs: Expr.Num 1 },
            ifTrue: Expr.Num 1,
            ifFalse: App {
                lhs: Var "f",
                arg: Bin { lhs: Var "n", op: Sub, rhs: Expr.Num 1 },
            },
        },
    },
    rhs: App { lhs: Var "f", arg: Expr.Num n },
}

print(fact(17)->eval(env))
